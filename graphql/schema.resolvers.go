package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.76

import (
	"context"
	"strconv"

	"github.com/JaLe29/search-me-plz-sktorrent/internal/database"
)

func mapTorrentWithStatsToGraphQL(t database.TorrentWithStats) *Torrent {
	return &Torrent{
		ID:         t.ID,
		Name:       t.Name,
		Category:   t.Category,
		SizeMb:     t.SizeMB,
		AddedDate:  t.AddedDate,
		URL:        t.URL,
		ImageURL:   &t.ImageURL,
		CsfdRating: &t.CSFDRating,
		CsfdURL:    &t.CSFDURL,
		CreatedAt:  t.CreatedAt,
		UpdatedAt:  t.UpdatedAt,
		Seeds:      t.Seeds,
		Leeches:    t.Leeches,
	}
}

// Torrent is the resolver for the torrent field.
func (r *queryResolver) Torrent(ctx context.Context, id string) (*Torrent, error) {
	t, err := r.DB.GetTorrentWithCurrentStats(id)
	if err != nil {
		return nil, err
	}
	return mapTorrentWithStatsToGraphQL(*t), nil
}

// Torrents is the resolver for the torrents field.
func (r *queryResolver) Torrents(ctx context.Context, first *int, after *string, category *string, search *string, sortBy *TorrentSortBy) (*TorrentConnection, error) {
	limit := 20
	if first != nil {
		limit = *first
	}

	// Parse offset from after cursor
	offset := 0
	if after != nil && *after != "" {
		if parsedOffset, err := strconv.Atoi(*after); err == nil {
			offset = parsedOffset
		}
	}

	// Convert sortBy enum to string
	sortByStr := "NEWEST"
	if sortBy != nil {
		sortByStr = string(*sortBy)
	}

	// Get torrents with pagination
	torrents, totalCount, hasNextPage, err := r.DB.GetTorrentsWithPagination(offset, limit, category, search, sortByStr)
	if err != nil {
		return nil, err
	}

	// Convert to GraphQL format
	var gqlTorrents []*Torrent
	for _, t := range torrents {
		gqlTorrents = append(gqlTorrents, mapTorrentWithStatsToGraphQL(t))
	}

	// Calculate hasPreviousPage
	hasPreviousPage := offset > 0

	return &TorrentConnection{
		Torrents:        gqlTorrents,
		TotalCount:      totalCount,
		HasNextPage:     hasNextPage,
		HasPreviousPage: hasPreviousPage,
	}, nil
}

// RecentTorrents is the resolver for the recentTorrents field.
func (r *queryResolver) RecentTorrents(ctx context.Context, limit *int) ([]*Torrent, error) {
	l := 20
	if limit != nil {
		l = *limit
	}
	torrents, err := r.DB.GetRecentTorrents(l)
	if err != nil {
		return nil, err
	}
	var gqlTorrents []*Torrent
	for _, t := range torrents {
		gqlTorrents = append(gqlTorrents, mapTorrentWithStatsToGraphQL(t))
	}
	return gqlTorrents, nil
}

// SearchTorrents is the resolver for the searchTorrents field.
func (r *queryResolver) SearchTorrents(ctx context.Context, query string, limit *int) ([]*Torrent, error) {
	l := 20
	if limit != nil {
		l = *limit
	}
	torrents, err := r.DB.SearchTorrents(query, l)
	if err != nil {
		return nil, err
	}
	var gqlTorrents []*Torrent
	for _, t := range torrents {
		gqlTorrents = append(gqlTorrents, mapTorrentWithStatsToGraphQL(t))
	}
	return gqlTorrents, nil
}

// TorrentsByCategory is the resolver for the torrentsByCategory field.
func (r *queryResolver) TorrentsByCategory(ctx context.Context, category string, limit *int) ([]*Torrent, error) {
	l := 20
	if limit != nil {
		l = *limit
	}
	torrents, err := r.DB.GetTorrentsByCategory(category, l)
	if err != nil {
		return nil, err
	}
	var gqlTorrents []*Torrent
	for _, t := range torrents {
		gqlTorrents = append(gqlTorrents, mapTorrentWithStatsToGraphQL(t))
	}
	return gqlTorrents, nil
}

// TorrentsByCsfdid is the resolver for the torrentsByCSFDID field.
func (r *queryResolver) TorrentsByCsfdid(ctx context.Context, csfdID string, limit *int) ([]*Torrent, error) {
	l := 20
	if limit != nil {
		l = *limit
	}
	torrents, err := r.DB.GetTorrentsByCSFDID(csfdID, l)
	if err != nil {
		return nil, err
	}
	var gqlTorrents []*Torrent
	for _, t := range torrents {
		gqlTorrents = append(gqlTorrents, mapTorrentWithStatsToGraphQL(t))
	}
	return gqlTorrents, nil
}

// Categories is the resolver for the categories field.
func (r *queryResolver) Categories(ctx context.Context) ([]*Category, error) {
	stats, err := r.DB.GetStats()
	if err != nil {
		return nil, err
	}
	var categories []*Category
	for k, v := range stats {
		if k == "total" || k == "stats_records" {
			continue
		}
		categories = append(categories, &Category{Name: k, Count: v})
	}
	return categories, nil
}

// Stats is the resolver for the stats field.
func (r *queryResolver) Stats(ctx context.Context) (*DatabaseStats, error) {
	stats, err := r.DB.GetStats()
	if err != nil {
		return nil, err
	}
	total := stats["total"]
	var categories []*Category
	for k, v := range stats {
		if k == "total" || k == "stats_records" {
			continue
		}
		categories = append(categories, &Category{Name: k, Count: v})
	}
	return &DatabaseStats{
		TotalTorrents:   total,
		TotalCategories: len(categories),
		CategoryCounts:  categories,
	}, nil
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//  - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//    it when you're done.
//  - You have helper methods in this file. Move them out to keep these resolver files clean.
/*
	func mapTorrentWithStatsToGraphQL(t database.TorrentWithStats) *Torrent {
	return &Torrent{
		ID:         t.ID,
		Name:       t.Name,
		Category:   t.Category,
		SizeMb:     t.SizeMB,
		AddedDate:  t.AddedDate,
		URL:        t.URL,
		ImageURL:   &t.ImageURL,
		CsfdRating: &t.CSFDRating,
		CsfdURL:    &t.CSFDURL,
		CreatedAt:  t.CreatedAt,
		UpdatedAt:  t.UpdatedAt,
		Seeds:      t.Seeds,
		Leeches:    t.Leeches,
	}
}
func (r *queryResolver) TorrentsByCSFDID(ctx context.Context, csfdID string, limit *int) ([]*Torrent, error) {
	l := 20
	if limit != nil {
		l = *limit
	}
	torrents, err := r.DB.GetTorrentsByCSFDID(csfdID, l)
	if err != nil {
		return nil, err
	}
	var gqlTorrents []*Torrent
	for _, t := range torrents {
		gqlTorrents = append(gqlTorrents, mapTorrentWithStatsToGraphQL(t))
	}
	return gqlTorrents, nil
}
*/
